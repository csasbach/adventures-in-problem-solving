# Asynchronous processing for long-running requests using Firestore
I was having some trouble with requests to initialize profile data for new users that relied on expensive long-running queries to the blockchain.  These requests were being made on mobile devices so this was both a bad user experience and an inconsistent result because many times the connection would not hold out for the duration of the request.  Also if many users initialized long-running data all at once, say after a major update, then concurrency could play a role in a lot of failures.

To solve this I used an architecture whereby a request is made to an API endpoint that immediately returns an OK response and then kicks off the actual work asynchronously.  When the work is complete it writes the results to a collection in Firestore.  If it fails it logs its errors to Firestore as well.  The app is always reactively listening to the Firestore collection, so when the results are eventually received they are shown instantly in the app.

In addition, other processes on the backend can monitor errors, handle sending notifications, or any other follow-up processes.  This architecture also allows for the core work to be broken down into chunks that can be handled by smaller serverless cloud infrastructure components rather than long-running processes that then require app services, containers, or virtual machines.  This saves money on compute, storage, network, DevOps, and monitoring, just to name a few.
