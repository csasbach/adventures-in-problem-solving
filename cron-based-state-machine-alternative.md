# Cron-based state machine alternative
I was working at a small startup and we were having problems with a process that was meant to provision crypto wallets to customers who had paid for them in one of the mobile app stores.  There were many moving parts some of which varied depending on which mobile store the purchase was made from, some of which relied on information from one of two different blockchains.

Purchase verification was implemented via cloud function handlers that interacted with callbacks in the app stores.  Provisioning of the wallets was handled by making calls on the appropriate blockchain.  Delivery was controlled by setting the resulting values in the appropriate user document in a Firestore collection.  Some of these steps could take a very long time to complete, were an impediment to further steps in the process until they were completed, and were expensive (as in cost money) and could break things downstream if repeated unnecessarily, particularly ones that involved blockchain.  The process was failing at all different points and troubleshooting and remediation were very slow and manual.  This was a terrible experience for us and our customers.

I did not write the original process but was tasked with making the needed improvements.  At first, I had contemplated building a finite state machine but then I realized two features of the existing implementation:  It was triggered on a cron in an Azure cloud function that could not run longer than 10 minutes and it was interacting with other internal systems via Event Hub in Azure cloud.

Since I didn't have a server from which to host a long-running in-memory process, and doing so would increase costs and take longer to build, I decided instead to use the architecture that was already there and build a cron and events based alternative to state machines that works like this:

**Verify state in reverse.**  For all events that have not been confirmed to be complete, verify the state of that event, starting with the final expected state.  If the event is in the final expected state, confirm completion, if not, verify the previous step.  If the previous step is completed confirm that step and then execute the final step, if not, verify the step before that, and so on until a step is unverified.  Then check if the unverified step is already in progress, if not flag it as in progress and begin executing that step.  Following this logic, each time the cron runs and processes a batch of events, each event will verify and confirm the step it executed previously then fail to verify and therefore mark it as in progress and process the step that it is currently on and no other.

**Verify on the source of truth and update the process state using simple storage.**  Verification of certain steps is expensive so once a thing has been verified to be true mark that in a simple storage system so that steps that are confirmed are not verified at the source over and over again.  If the verification is false, write an 'in progress' record to simple storage so that it won't be executed more than once or verified more than once while still in progress either.

**Write to simple storage with events so that state transitions are idempotent.**  Once you've verified a step and want to confirm it, you don't want that confirmation to get lost in transit.  Use a system designed for managing idempotent events to confirm verified events or when marking an unverified event as in progress.

**Final confirmation is the system being in the desired state.**  Final confirmation should be done by checking the desired state itself.  This way there is no doubt the process is truly complete.

**Log everything.**  Each time the process runs in the cron it should be logging every verification, every event it fired, every piece of work executed, and whether it's in progress; to aid in troubleshooting and to alert when certain events have become stuck.  This way troubleshooting and remediation are done immediately for a specific event stuck at a specific step in the process.

By following these steps, the cron can handle slow running, flaky steps and almost always arrive in a state of eventual consistency, and when it doesn't, alert the team to specific actionable remediations.
