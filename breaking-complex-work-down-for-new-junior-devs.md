# Breaking complex work down for new junior devs
At a mid-to-large-sized-company We had an outage in an internal platform application that ended up impacting a fair number of internal products that collectively impacted a fair number of external customers.  In the post-mortem, it was determined that my team would implement a feature that would provide a preventative layer of protection so this particular type of outage would not happen again.

Being experienced with the product in question, I had designed a solution that was relatively complex but I felt I could complete it in about a month if I were 'heads down' and focused entirely on the implementation.  Unfortunately, I was not a resource that would be allocated to putting out this particular fire because I was already working on another high-priority project.

Instead, I was tasked with delegating this work to our comparatively inexperienced set of junior developers, this was pre-pandemic, but they were all off-shore, so this would be an entirely remote collaboration.  I needed to break the problem down into stories that the product owner could assign to the junior developers and I needed a definition of done clear enough that QA could validate each step of the work without much assistance from me.

The biggest help in delegating tasks of this magnitude turned out to come from a very unexpected place.  Test Driven Development.  If you are already fluent in breaking your stories down into testable, modular code, then you've already won half the battle.  It's really that simple, stub out your tests, translate those ideas into formal test cases and requirements, and hand those off to the PO and QA.  Then as the code reviews start coming in, keep an eye on the progress and make sure everyone has stayed aligned or adjusted the requirements for any unforeseen complications.

One other major help was having already established good design patterns and habits.  We had well-defined general requirements for things like API endpoints, database connections, remote configuration, and infrastructure as code for CI/CD pipelines.  Our repositories already contained examples of well-defined abstractions, well-written tests, and where and how to implement shared business logic.

Finally, make maintaining all of the above and including good documentation a part of your definition of done, and don't allow a story to get past code review or QA until it is done right.  If you do those things, have fast feedback loops, and make sure you keep your requirements aligned with the reality on the ground, then you will be able to deliver quality software even with the newest recruits.

In the end, it took more than a month to complete the project and there were even gaps in the development due to other priorities slipping in for those developers, but the initial design held and the project was eventually delivered successfully while I continued to work on other new development. Those new developers were able to gain a lot of autonomy in a short amount of time and move on to more successes of their own.
